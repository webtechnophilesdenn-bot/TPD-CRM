  document.addEventListener('DOMContentLoaded', function () {
            // Intersection Observer for animations
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const delay = parseInt(entry.target.dataset.delay || 0, 10);
                        setTimeout(() => {
                            entry.target.classList.add('animate');
                        }, delay);
                        observer.unobserve(entry.target);
                    }
                });
            }, {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            });
            
            document.querySelectorAll('[data-animate]').forEach(el => observer.observe(el));
            
            // Smooth scroll for internal links
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    const target = document.querySelector(this.getAttribute('href'));
                    if (!target) return;
                    e.preventDefault();
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                });
            });
        });


const chatContainer = document.getElementById('hero-chat-preview');
const chatWrapper = document.createElement('div');
chatWrapper.className = 'chat-wrapper';
chatContainer.appendChild(chatWrapper);

const chatMessages = [
  {user: true, content: "How can AI help my business?", avatar: "https://i.pravatar.cc/32?img=5"},
  {user: false, content: "AI automates FAQs, brings instant responses, and scales support.", avatar: "https://i.pravatar.cc/32?img=10"},
  {user: true, content: "Can it work with my website?", avatar: "https://i.pravatar.cc/32?img=6"},
  {user: false, content: "Yes! You can integrate it with just a few clicks.", avatar: "https://i.pravatar.cc/32?img=11"},
  {user: false, content: "Try now â€“ instant setup, no coding required.", avatar: "https://i.pravatar.cc/32?img=11"},
];

let idx = 0;
function addChatMessage() {
  if (idx >= chatMessages.length) idx = 0;
  const msg = chatMessages[idx++];
  const msgDiv = document.createElement("div");
  msgDiv.className = "hero-message " + (msg.user ? "user" : "bot");
  msgDiv.innerHTML = `
    <div class="avatar"><img src="${msg.avatar}" /></div>
    <div class="message-content">${msg.content}</div>
  `;
  chatWrapper.appendChild(msgDiv);

  if (chatWrapper.children.length > 5) {
    chatWrapper.removeChild(chatWrapper.children[0]);
  }
}

for(let i=0; i<5; i++) addChatMessage();

setInterval(() => {
  addChatMessage();
}, 2000);





            function toggleStep(titleElement) {
      const stepDiv = titleElement.parentElement;
      const desc = stepDiv.querySelector(".step-desc");
      const icon = titleElement.querySelector(".step-icon");
      if (desc.classList.contains("hidden")) {
        desc.classList.remove("hidden");
        icon.innerHTML = "&#10005;"; // cross symbol
      } else {
        desc.classList.add("hidden");
        icon.innerHTML = "+";
      }
    }




            function toggleStep(titleElement) {
            const stepDiv = titleElement.parentElement;
            const desc = stepDiv.querySelector(".step-desc");
            const icon = titleElement.querySelector(".step-icon");
            
            if (desc.classList.contains("hidden")) {
                desc.classList.remove("hidden");
                icon.innerHTML = "&#10005;"; // cross symbol
            } else {
                desc.classList.add("hidden");
                icon.innerHTML = "+";
            }
        }









         class AnimatedBeam {
        constructor(options) {
          this.container = options.container;
          this.fromElement = options.fromElement;
          this.toElement = options.toElement;
          this.svg = options.svg;
          this.curvature = options.curvature || 0;
          this.reverse = options.reverse || false;
          this.duration = options.duration || 1.5;
          this.delay = options.delay || 0;
          this.gradientStartColor = options.gradientStartColor || "#87CEEB";
          this.gradientStopColor = options.gradientStopColor || "#4682B4";

          this.id = "gradient-" + Math.random().toString(36).substr(2, 9);
          this.init();
        }

        init() {
          this.createPaths();
          this.updatePath();

          const resizeObserver = new ResizeObserver(() => {
            this.updatePath();
          });

          resizeObserver.observe(this.container);
          this.animate();
        }

        createPaths() {
          this.bgPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          this.bgPath.classList.add("beam-path", "beam-path-bg");
          this.bgPath.setAttribute("stroke-width", "2");

          this.animPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          this.animPath.classList.add("beam-path", "beam-path-animated");
          this.animPath.setAttribute("stroke-width", "2");
          this.animPath.setAttribute("stroke", `url(#${this.id})`);

          const defs = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "defs"
          );
          this.gradient = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "linearGradient"
          );
          this.gradient.setAttribute("id", this.id);
          this.gradient.setAttribute("gradientUnits", "userSpaceOnUse");

          const stop1 = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "stop"
          );
          stop1.setAttribute("stop-color", this.gradientStartColor);
          stop1.setAttribute("stop-opacity", "0");

          const stop2 = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "stop"
          );
          stop2.setAttribute("stop-color", this.gradientStartColor);

          const stop3 = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "stop"
          );
          stop3.setAttribute("offset", "32.5%");
          stop3.setAttribute("stop-color", this.gradientStopColor);

          const stop4 = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "stop"
          );
          stop4.setAttribute("offset", "100%");
          stop4.setAttribute("stop-color", this.gradientStopColor);
          stop4.setAttribute("stop-opacity", "0");

          this.gradient.appendChild(stop1);
          this.gradient.appendChild(stop2);
          this.gradient.appendChild(stop3);
          this.gradient.appendChild(stop4);
          defs.appendChild(this.gradient);

          this.svg.appendChild(defs);
          this.svg.appendChild(this.bgPath);
          this.svg.appendChild(this.animPath);
        }

        updatePath() {
          const containerRect = this.container.getBoundingClientRect();
          const fromRect = this.fromElement.getBoundingClientRect();
          const toRect = this.toElement.getBoundingClientRect();

          const startX =
            fromRect.left - containerRect.left + fromRect.width / 2;
          const startY = fromRect.top - containerRect.top + fromRect.height / 2;
          const endX = toRect.left - containerRect.left + toRect.width / 2;
          const endY = toRect.top - containerRect.top + toRect.height / 2;

          const controlY = startY - this.curvature;
          const pathD = `M ${startX},${startY} Q ${
            (startX + endX) / 2
          },${controlY} ${endX},${endY}`;

          this.bgPath.setAttribute("d", pathD);
          this.animPath.setAttribute("d", pathD);

          this.gradient.setAttribute("x1", startX);
          this.gradient.setAttribute("y1", startY);
          this.gradient.setAttribute("x2", endX);
          this.gradient.setAttribute("y2", endY);
        }

        animate() {
          const coords = this.reverse
            ? { x1: ["90%", "-10%"], x2: ["100%", "0%"] }
            : { x1: ["10%", "110%"], x2: ["0%", "100%"] };

          let progress = 0;
          const animate = () => {
            progress += 0.016 / this.duration;
            if (progress > 1) progress = 0;

            const easeOutExpo =
              progress === 1 ? 1 : 1 - Math.pow(2, -10 * progress);

            const x1Start = parseFloat(coords.x1[0]);
            const x1End = parseFloat(coords.x1[1]);
            const x2Start = parseFloat(coords.x2[0]);
            const x2End = parseFloat(coords.x2[1]);

            const x1 = x1Start + (x1End - x1Start) * easeOutExpo;
            const x2 = x2Start + (x2End - x2Start) * easeOutExpo;

            this.gradient.setAttribute("x1", x1 + "%");
            this.gradient.setAttribute("x2", x2 + "%");
            this.gradient.setAttribute("y1", "0%");
            this.gradient.setAttribute("y2", "0%");

            requestAnimationFrame(animate);
          };

          setTimeout(() => {
            animate();
          }, this.delay * 1000);
        }
      }

      const container = document.getElementById("container");
      const svg = document.getElementById("beamSvg");

      // Connect all left nodes to center only
      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node1"),
        toElement: document.getElementById("node6"),
        svg: svg,
        duration: 2.2,
        delay: 0,
      });

      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node2"),
        toElement: document.getElementById("node6"),
        svg: svg,
        duration: 2.4,
        delay: 0.2,
      });

      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node3"),
        toElement: document.getElementById("node6"),
        svg: svg,
        duration: 2.3,
        delay: 0.3,
      });

      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node4"),
        toElement: document.getElementById("node6"),
        svg: svg,
        duration: 2.5,
        delay: 0.4,
      });

      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node5"),
        toElement: document.getElementById("node6"),
        svg: svg,
        duration: 2.3,
        delay: 0.5,
      });

      // Connect center to all right nodes only
      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node6"),
        toElement: document.getElementById("node7"),
        svg: svg,
        duration: 2.2,
        delay: 0.6,
      });

      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node6"),
        toElement: document.getElementById("node8"),
        svg: svg,
        duration: 2.4,
        delay: 0.7,
      });

      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node6"),
        toElement: document.getElementById("node9"),
        svg: svg,
        duration: 2.3,
        delay: 0.8,
      });

      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node6"),
        toElement: document.getElementById("node10"),
        svg: svg,
        duration: 2.5,
        delay: 0.9,
      });

      new AnimatedBeam({
        container: container,
        fromElement: document.getElementById("node6"),
        toElement: document.getElementById("node11"),
        svg: svg,
        duration: 2.4,
        delay: 1.0,
      });